C51 COMPILER V8.02   GLCD                                                                  10/14/2013 21:18:05 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE GLCD
OBJECT MODULE PLACED IN glcd.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE glcd.c OMF2 BROWSE DEBUG

line level    source

   1          #include <reg52.h>
   2          #include <string.h>
   3          #include "glcd.h"
   4          #include "fonts.h"
   5          
   6          void waiting(void){
   7   1              while(1){
   8   2                      RS=0;
   9   2                      RW=1;
  10   2                      En=0;
  11   2                      LCDdata=0xFF;
  12   2                      En=1;
  13   2                      if((LCDdata&0x80)==0) break;
  14   2              }
  15   1      }
  16          
  17          void lcd_write_command(unsigned char command){
  18   1              waiting();
  19   1              RS=0;
  20   1              RW=0;
  21   1              En=1;
  22   1              LCDdata=command;
  23   1              En=0;
  24   1      }
  25          
  26          void lcd_write_data(unsigned char RWdata){
  27   1              waiting();
  28   1              RS=1;
  29   1              RW=0;
  30   1              En=1;
  31   1              LCDdata=RWdata;
  32   1              En=0;
  33   1      }
  34          
  35          unsigned char lcd_read_data(void){
  36   1              unsigned char Rdata;
  37   1              waiting();
  38   1              RS=1;
  39   1              RW=1;
  40   1              En=1;
  41   1              Rdata=P0;
  42   1              En=0;
  43   1              return Rdata;
  44   1      }
  45          
  46          void lcd_init(void){
  47   1              PSB=1;
  48   1              RET=1;
  49   1              lcd_write_command(BasicCommand);
  50   1              lcd_write_command(ClearScreen);
  51   1              lcd_write_command(AddrBackO);
  52   1              lcd_write_command(CurserOff);
  53   1              lcd_write_command(ClearScreen);
  54   1              lcd_write_command(CurserLeft);
  55   1      }
C51 COMPILER V8.02   GLCD                                                                  10/14/2013 21:18:05 PAGE 2   

  56          
  57          void display_string(unsigned char line,unsigned char *string){
  58   1      //Use the default command to display string. It can display chinese
  59   1      //line is the number of line. There are total 4 lines
  60   1      //string must be like this: unsigned char code string_1[]={"Test"}
  61   1      //Maxmum number of characters is 16.
  62   1          unsigned char  addr,i;
  63   1              unsigned char  maxnum=strlen(string);
  64   1          if(line==1)
  65   1            addr=0x80;
  66   1          else if(line==2)
  67   1            addr=0x90;
  68   1          else if(line==3)
  69   1            addr=0x88;
  70   1          else if(line==4)
  71   1                      addr=0x98;
  72   1          lcd_write_command(addr);
  73   1          for(i=0;i<maxnum;i++)
  74   1          {
  75   2                      lcd_write_data(*string++);
  76   2              } 
  77   1      }
  78          
  79          void first_page(void){
  80   1              unsigned char i,j;
  81   1              lcd_write_command(ExteCommandOff);
  82   1              for(i=0;i<16;i++){
  83   2                      for(j=0;j<32;j++){
  84   3                              lcd_write_command(0x80|j);
  85   3                              lcd_write_command(i|0x80);
  86   3                              lcd_write_data(0x00);
  87   3                              lcd_write_data(0x00);   
  88   3                      }
  89   2              }
  90   1              lcd_write_command(ExteCommandOn);
  91   1              lcd_write_command(BasicCommand);
  92   1      }
  93          
  94          void set_dot(unsigned char x,unsigned char y){
  95   1              if(x>=0 && x<=127 && y>=0 && y<=63){
  96   2              //initial variables
  97   2              unsigned int k=0x8000;
  98   2              unsigned char highdata,lowdata;
  99   2              //Open external command and graphic display
 100   2              lcd_write_command(ExteCommandOn);
 101   2              //According to y, adjust x and y
 102   2              if(y>=32){
 103   3                      y=y-32;
 104   3                      x=x+128;
 105   3              }
 106   2              //according to x, get which bit will be setted.
 107   2              k=k>>x%16;
 108   2              //write x and y to prepare to read data
 109   2              lcd_write_command(0x80|y);
 110   2              lcd_write_command((x/16)|0x80);
 111   2              //read exist data and change them to new data.
 112   2              highdata=lcd_read_data();
 113   2              highdata=lcd_read_data()|k>>8;
 114   2              lowdata=lcd_read_data()|k;
 115   2              //write x and y to prepare to write data
 116   2              lcd_write_command(0x80|y);
 117   2              lcd_write_command((x/16)|0x80);
C51 COMPILER V8.02   GLCD                                                                  10/14/2013 21:18:05 PAGE 3   

 118   2              //write data
 119   2              lcd_write_data(highdata);
 120   2              lcd_write_data(lowdata);
 121   2              //go back to basic command
 122   2              lcd_write_command(BasicCommand);
 123   2              }
 124   1      }
 125          
 126          void draw_line(unsigned char x1,unsigned char y1,unsigned char x2,unsigned char y2){    
 127   1              char dx,dy;//Difference between x1 and x2 and difference between y1 and y2
 128   1              unsigned char x,y,temp;//x,y: location of pixel.  temp: temp value for exchange of x and y
 129   1              int e;//adjust whether should be increased
 130   1              bit k,j;//k: upper slope flag.  j: negative slope flag
 131   1              dx=x2-x1;
 132   1              dy=y2-y1;
 133   1              //if the line is not from high to low, change it.
 134   1              if((dx<=0 && dy<=0) || (dx>=0 && dy<=0)){
 135   2                      temp=x2;
 136   2                      x2=x1;
 137   2                      x1=temp;
 138   2                      temp=y2;
 139   2                      y2=y1;
 140   2                      y1=temp;
 141   2                      dx=x2-x1;
 142   2                      dy=y2-y1;
 143   2              }
 144   1              //if negative slope, change to positive and get flag
 145   1              if(dx<0){
 146   2                      temp=x2;
 147   2                      x2=x1;
 148   2                      x1=temp;
 149   2                      dx=x2-x1;
 150   2                      j=1;
 151   2              }else{
 152   2                      j=0;
 153   2              }
 154   1              //if upper slope, get flag
 155   1              if(dx>=dy){
 156   2                      k=1;    
 157   2              }else{
 158   2                      k=0;
 159   2              }
 160   1              //Different slope, different default e
 161   1              if(k){
 162   2                      e=-dx;
 163   2              }else{
 164   2                      e=-dy;
 165   2              }
 166   1              //first point
 167   1              x=x1;
 168   1              y=y1;
 169   1              //if has been finished final point, finish drawing.
 170   1              while(x<=x2 && y<=y2){
 171   2                      //if the original slope is negative slope, should  change points back
 172   2                      if(j){
 173   3                              set_dot(x1+x2-x,y);
 174   3                      }else{
 175   3                              set_dot(x,y);
 176   3                      }
 177   2                      //different slope, different change of e
 178   2                      if(k){
 179   3                              e=e+2*dy;
C51 COMPILER V8.02   GLCD                                                                  10/14/2013 21:18:05 PAGE 4   

 180   3                      }else{
 181   3                              e=e+2*dx;
 182   3                      }
 183   2                      //according to e, adjust whether should go upper
 184   2                      if(e<=0){
 185   3                              //different slope, different way to go upper
 186   3                              if(k){
 187   4                                      x++;
 188   4                              }else{
 189   4                                      y++;
 190   4                              }
 191   3                      }else{
 192   3                              x++;
 193   3                              y++;
 194   3                              //different slope, different change of e
 195   3                              if(k){
 196   4                                      e=e-2*dx;
 197   4                              }else{
 198   4                                      e=e-2*dy;
 199   4                              }
 200   3                      }
 201   2              }
 202   1      }
 203          
 204          void draw_box(unsigned char x,unsigned char y,unsigned char num_x,unsigned char num_y,bit fill){
 205   1              //x: right upper coner x
 206   1              //y: right upper coner y
 207   1              //num_x: number of pixels in x
 208   1              //num_y: number os pixels in y
 209   1              //fill: fill or not
 210   1              if(fill){
 211   2                      unsigned char i;
 212   2                      for(i=y;i<y+num_y;i++){
 213   3                              draw_line(x,i,x+num_x-1,i);
 214   3                      }
 215   2              }else{
 216   2                      draw_line(x,y,x,y+num_y-1);
 217   2                      draw_line(x,y,x+num_x-1,y);
 218   2                      draw_line(x+num_x-1,y+num_y-1,x+num_x-1,y);
 219   2                      draw_line(x+num_x-1,y+num_y-1,x,y+num_y-1);
 220   2              }
 221   1      }
 222          
 223          void draw_frame(void){
 224   1              draw_box(0,0,128,64,0);
 225   1      }
 226          
 227          void draw_circle(unsigned char x,unsigned char y,unsigned char r,bit fill){
 228   1              //x: x of center
 229   1              //y: y of center
 230   1              //r: radius (number of pixels in radius)
 231   1              //fill: fill or not
 232   1              unsigned char a,b;
 233   1              char d;
 234   1              unsigned char i;
 235   1              //initial first point
 236   1              a=0;
 237   1              b=r-1;
 238   1              //initial distance
 239   1              d=1-r;
 240   1              while(a<=b){//Adjust if circle has been finished
 241   2                      //draw circle using a point of 1/8 circle to draw 8 points in all circle
C51 COMPILER V8.02   GLCD                                                                  10/14/2013 21:18:05 PAGE 5   

 242   2                      if(fill){
 243   3                              for(i=a+x;i>=x-a;i--){
 244   4                                      set_dot(i,b+y);
 245   4                                      set_dot(i,y-b);
 246   4                              }
 247   3                              for(i=b+x;i>=x-b;i--){
 248   4                                      set_dot(i,a+y);
 249   4                                      set_dot(i,y-a);
 250   4                              }
 251   3                      }else{
 252   3                              set_dot(a+x,b+y);
 253   3                              set_dot(a+x,y-b);
 254   3                              set_dot(x-a,b+y);
 255   3                              set_dot(x-a,y-b);
 256   3                              set_dot(b+x,a+y);
 257   3                              set_dot(b+x,y-a);
 258   3                              set_dot(x-b,a+y);
 259   3                              set_dot(x-b,y-a);       
 260   3                      }
 261   2                      //use distance to adjust next point.
 262   2                      if(d<0){
 263   3                              d+=2*a+3;
 264   3                      }else{
 265   3                              d+=2*(a-b)+5;
 266   3                              b--;
 267   3                      }
 268   2                      a++;
 269   2              }
 270   1      }
 271          
 272          void draw_8bits(unsigned char x,unsigned char y,unsigned char data8bit){
 273   1              unsigned char i=8;
 274   1              bit dot;
 275   1              while(i>0){
 276   2                      i--;
 277   2                      dot=0x01&(data8bit>>i);
 278   2                      if(dot){
 279   3                              set_dot(x,y);
 280   3                      }
 281   2                      x++;
 282   2              }
 283   1      }
 284          
 285          void draw_8bits90(unsigned char x,unsigned char y,unsigned char data8bit){
 286   1              unsigned char i=8;
 287   1              bit dot;
 288   1              while(i>0){
 289   2                      i--;
 290   2                      dot=0x01&(data8bit>>i);
 291   2                      if(dot){
 292   3                              set_dot(x,y);
 293   3                      }
 294   2                      y++;
 295   2              }
 296   1      }
 297          
 298          void draw_8bits180(unsigned char x,unsigned char y,unsigned char data8bit){
 299   1              unsigned char i=8;
 300   1              bit dot;
 301   1              while(i>0){
 302   2                      i--;
 303   2                      dot=0x01&(data8bit>>i);
C51 COMPILER V8.02   GLCD                                                                  10/14/2013 21:18:05 PAGE 6   

 304   2                      if(dot){
 305   3                              set_dot(x,y);
 306   3                      }
 307   2                      x--;
 308   2              }
 309   1      }
 310          
 311          void draw_8bits270(unsigned char x,unsigned char y,unsigned char data8bit){
 312   1              unsigned char i=8;
 313   1              bit dot;
 314   1              while(i>0){
 315   2                      i--;
 316   2                      dot=0x01&(data8bit>>i);
 317   2                      if(dot){
 318   3                              set_dot(x,y);
 319   3                      }
 320   2                      y--;
 321   2              }
 322   1      }
 323          
 324          void draw_picture(unsigned char x,unsigned char y,unsigned char x_l,unsigned char y_l,unsigned char *pictu
             -re){
 325   1              //x_l and y_l must be multiples of 8. They are the picture's length(in x of original system) and width(in
             - y of original system).
 326   1              unsigned char i=0;
 327   1              unsigned char j=0;
 328   1              int num=0;
 329   1              x_l=x_l/8;
 330   1              while(j<y_l){
 331   2                      j++;
 332   2                      while(i<x_l){
 333   3                              i++;
 334   3                              draw_8bits(x,y,picture[num]);
 335   3                              num++;
 336   3                              x+=8;
 337   3      
 338   3                      }
 339   2                      x-=8*i;
 340   2                      i=0;
 341   2                      y++;
 342   2              }
 343   1      }
 344          
 345          void draw_picture90(unsigned char x,unsigned char y,unsigned char x_l,unsigned char y_l,unsigned char *pic
             -ture){
 346   1              //x_l and y_l must be multiples of 8. They are the picture's length(in x of original system) and width(in
             - y of original system).
 347   1              unsigned char i=0;
 348   1              unsigned char j=0;
 349   1              int num=0;
 350   1              x_l=x_l/8;
 351   1              while(j<y_l){
 352   2                      j++;
 353   2                      while(i<x_l){
 354   3                              i++;
 355   3                              draw_8bits90(x,y,picture[num]);
 356   3                              num++;
 357   3                              y+=8;
 358   3      
 359   3                      }
 360   2                      y-=8*i;
 361   2                      i=0;
C51 COMPILER V8.02   GLCD                                                                  10/14/2013 21:18:05 PAGE 7   

 362   2                      x--;
 363   2              }
 364   1      }
 365          
 366          void draw_picture180(unsigned char x,unsigned char y,unsigned char x_l,unsigned char y_l,unsigned char *pi
             -cture){
 367   1              //x_l and y_l must be multiples of 8. They are the picture's length(in x of original system) and width(in
             - y of original system).
 368   1              unsigned char i=0;
 369   1              unsigned char j=0;
 370   1              int num=0;
 371   1              x_l=x_l/8;
 372   1              while(j<y_l){
 373   2                      j++;
 374   2                      while(i<x_l){
 375   3                              i++;
 376   3                              draw_8bits180(x,y,picture[num]);
 377   3                              num++;
 378   3                              x-=8;
 379   3      
 380   3                      }
 381   2                      x+=8*i;
 382   2                      i=0;
 383   2                      y--;
 384   2              }
 385   1      }
 386          
 387          void draw_picture270(unsigned char x,unsigned char y,unsigned char x_l,unsigned char y_l,unsigned char *pi
             -cture){
 388   1              //x_l and y_l must be multiples of 8. They are the picture's length(in x of original system) and width(in
             - y of original system).
 389   1              unsigned char i=0;
 390   1              unsigned char j=0;
 391   1              int num=0;
 392   1              x_l=x_l/8;
 393   1              while(j<y_l){
 394   2                      j++;
 395   2                      while(i<x_l){
 396   3                              i++;
 397   3                              draw_8bits270(x,y,picture[num]);
 398   3                              num++;
 399   3                              y-=8;
 400   3      
 401   3                      }
 402   2                      y+=8*i;
 403   2                      i=0;
 404   2                      x++;
 405   2              }
 406   1      }
 407          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1589    ----
   CONSTANT SIZE    =  33204    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      77
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       8
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
C51 COMPILER V8.02   GLCD                                                                  10/14/2013 21:18:05 PAGE 8   

   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
