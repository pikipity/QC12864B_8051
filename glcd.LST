C51 COMPILER V8.02   GLCD                                                                  10/12/2013 23:17:28 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE GLCD
OBJECT MODULE PLACED IN glcd.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE glcd.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h>
   2          #include <string.h>
   3          #include "glcd.h"
   4          
   5          void waiting(void){
   6   1              while(1){
   7   2                      RS=0;
   8   2                      RW=1;
   9   2                      En=0;
  10   2                      LCDdata=0xFF;
  11   2                      En=1;
  12   2                      if((LCDdata&0x80)==0) break;
  13   2              }
  14   1      }
  15          
  16          void lcd_write_command(unsigned char command){
  17   1              waiting();
  18   1              RS=0;
  19   1              RW=0;
  20   1              En=1;
  21   1              LCDdata=command;
  22   1              En=0;
  23   1      }
  24          
  25          void lcd_write_data(unsigned char RWdata){
  26   1              waiting();
  27   1              RS=1;
  28   1              RW=0;
  29   1              En=1;
  30   1              LCDdata=RWdata;
  31   1              En=0;
  32   1      }
  33          
  34          unsigned char lcd_read_data(void){
  35   1              unsigned char Rdata;
  36   1              waiting();
  37   1              RS=1;
  38   1              RW=1;
  39   1              En=1;
  40   1              Rdata=P0;
  41   1              En=0;
  42   1              return Rdata;
  43   1      }
  44          
  45          void lcd_init(void){
  46   1              PSB=1;
  47   1              RET=1;
  48   1              lcd_write_command(BasicCommand);
  49   1              lcd_write_command(ClearScreen);
  50   1              lcd_write_command(AddrBackO);
  51   1              lcd_write_command(CurserOff);
  52   1              lcd_write_command(ClearScreen);
  53   1              lcd_write_command(CurserLeft);
  54   1      }
  55          
C51 COMPILER V8.02   GLCD                                                                  10/12/2013 23:17:28 PAGE 2   

  56          void display_string(unsigned char line,unsigned char *string){
  57   1      //Use the default command to display string. It can display chinese
  58   1      //line is the number of line. There are total 4 lines
  59   1      //string must be like this: unsigned char code string_1[]={"Test"}
  60   1      //Maxmum number of characters is 16.
  61   1          unsigned char  addr,i;
  62   1              unsigned char  maxnum=strlen(string);
  63   1          if(line==1)
  64   1            addr=0x80;
  65   1          else if(line==2)
  66   1            addr=0x90;
  67   1          else if(line==3)
  68   1            addr=0x88;
  69   1          else if(line==4)
  70   1                      addr=0x98;
  71   1          lcd_write_command(addr);
  72   1          for(i=0;i<maxnum;i++)
  73   1          {
  74   2                      lcd_write_data(*string++);
  75   2              } 
  76   1      }
  77          
  78          void first_page(void){
  79   1              unsigned char i,j;
  80   1              lcd_write_command(ExteCommandOff);
  81   1              for(i=0;i<16;i++){
  82   2                      for(j=0;j<32;j++){
  83   3                              lcd_write_command(0x80|j);
  84   3                              lcd_write_command(i|0x80);
  85   3                              lcd_write_data(0x00);
  86   3                              lcd_write_data(0x00);   
  87   3                      }
  88   2              }
  89   1              lcd_write_command(ExteCommandOn);
  90   1              lcd_write_command(BasicCommand);
  91   1      }
  92          
  93          void set_dot(unsigned char x,unsigned char y){
  94   1              //initial variables
  95   1              unsigned int k=0x8000;
  96   1              unsigned char highdata,lowdata;
  97   1              //Open external command and graphic display
  98   1              lcd_write_command(ExteCommandOn);
  99   1              //According to y, adjust x and y
 100   1              if(y>=32){
 101   2                      y=y-32;
 102   2                      x=x+128;
 103   2              }
 104   1              //according to x, get which bit will be setted.
 105   1              k=k>>x%16;
 106   1              //write x and y to prepare to read data
 107   1              lcd_write_command(0x80|y);
 108   1              lcd_write_command((x/16)|0x80);
 109   1              //read exist data and change them to new data.
 110   1              highdata=lcd_read_data();
 111   1              highdata=lcd_read_data()|k>>8;
 112   1              lowdata=lcd_read_data()|k;
 113   1              //write x and y to prepare to write data
 114   1              lcd_write_command(0x80|y);
 115   1              lcd_write_command((x/16)|0x80);
 116   1              //write data
 117   1              lcd_write_data(highdata);
C51 COMPILER V8.02   GLCD                                                                  10/12/2013 23:17:28 PAGE 3   

 118   1              lcd_write_data(lowdata);
 119   1              //go back to basic command
 120   1              lcd_write_command(BasicCommand);
 121   1      }
 122          
 123          void draw_line(unsigned char x1,unsigned char y1,unsigned char x2,unsigned char y2){    
 124   1              char dx,dy;//Difference between x1 and x2 and difference between y1 and y2
 125   1              unsigned char x,y,temp;//x,y: location of pixel.  temp: temp value for exchange of x and y
 126   1              int e;//adjust whether should be increased
 127   1              bit k,j;//k: upper slope flag.  j: negative slope flag
 128   1              dx=x2-x1;
 129   1              dy=y2-y1;
 130   1              //if the line is not from high to low, change it.
 131   1              if((dx<=0 && dy<=0) || (dx>=0 && dy<=0)){
 132   2                      temp=x2;
 133   2                      x2=x1;
 134   2                      x1=temp;
 135   2                      temp=y2;
 136   2                      y2=y1;
 137   2                      y1=temp;
 138   2                      dx=x2-x1;
 139   2                      dy=y2-y1;
 140   2              }
 141   1              //if negative slope, change to positive and get flag
 142   1              if(dx<0){
 143   2                      temp=x2;
 144   2                      x2=x1;
 145   2                      x1=temp;
 146   2                      dx=x2-x1;
 147   2                      j=1;
 148   2              }else{
 149   2                      j=0;
 150   2              }
 151   1              //if upper slope, get flag
 152   1              if(dx>=dy){
 153   2                      k=1;    
 154   2              }else{
 155   2                      k=0;
 156   2              }
 157   1              //Different slope, different default e
 158   1              if(k){
 159   2                      e=-dx;
 160   2              }else{
 161   2                      e=-dy;
 162   2              }
 163   1              //first point
 164   1              x=x1;
 165   1              y=y1;
 166   1              //if has been finished final point, finish drawing.
 167   1              while(x<=x2 && y<=y2){
 168   2                      //if the original slope is negative slope, should  change points back
 169   2                      if(j){
 170   3                              set_dot(x1+x2-x,y);
 171   3                      }else{
 172   3                              set_dot(x,y);
 173   3                      }
 174   2                      //different slope, different change of e
 175   2                      if(k){
 176   3                              e=e+2*dy;
 177   3                      }else{
 178   3                              e=e+2*dx;
 179   3                      }
C51 COMPILER V8.02   GLCD                                                                  10/12/2013 23:17:28 PAGE 4   

 180   2                      //according to e, adjust whether should go upper
 181   2                      if(e<=0){
 182   3                              //different slope, different way to go upper
 183   3                              if(k){
 184   4                                      x+=1;
 185   4                              }else{
 186   4                                      y+=1;
 187   4                              }
 188   3                      }else{
 189   3                              x+=1;
 190   3                              y+=1;
 191   3                              //different slope, different change of e
 192   3                              if(k){
 193   4                                      e=e-2*dx;
 194   4                              }else{
 195   4                                      e=e-2*dy;
 196   4                              }
 197   3                      }
 198   2              }
 199   1      }
 200          
 201          void draw_box(unsigned char x,unsigned char y,unsigned char num_x,unsigned char num_y,bit fill){
 202   1              //x: right upper coner x
 203   1              //y: right upper coner y
 204   1              //num_x: number of pixels in x
 205   1              //num_y: number os pixels in y
 206   1              //fill: fill or not
 207   1              if(fill){
 208   2                      unsigned char i;
 209   2                      for(i=y;i<y+num_y;i++){
 210   3                              draw_line(x,i,x+num_x-1,i);
 211   3                      }
 212   2              }else{
 213   2                      draw_line(x,y,x,y+num_y-1);
 214   2                      draw_line(x,y,x+num_x-1,y);
 215   2                      draw_line(x+num_x-1,y+num_y-1,x+num_x-1,y);
 216   2                      draw_line(x+num_x-1,y+num_y-1,x,y+num_y-1);
 217   2              }
 218   1      }
 219          
 220          void draw_frame(void){
 221   1              draw_box(0,0,128,64,0);
 222   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    751    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      19
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
