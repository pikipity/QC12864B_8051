C51 COMPILER V8.02   GLCD                                                                  10/17/2013 17:03:06 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE GLCD
OBJECT MODULE PLACED IN glcd.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE glcd.c OMF2 BROWSE DEBUG

line level    source

   1          #include <reg52.h>
   2          #include <string.h>
   3          #include "glcd.h"
   4          
   5          void waiting(void){
   6   1              while(1){
   7   2                      RS=0;
   8   2                      RW=1;
   9   2                      En=0;
  10   2                      LCDdata=0xFF;
  11   2                      En=1;
  12   2                      if((LCDdata&0x80)==0) break;
  13   2              }
  14   1      }
  15          
  16          void lcd_write_command(unsigned char command){
  17   1              waiting();
  18   1              RS=0;
  19   1              RW=0;
  20   1              LCDdata=command;
  21   1              En=1;
  22   1              En=0;
  23   1      }
  24          
  25          void lcd_write_data(unsigned char RWdata){
  26   1              waiting();
  27   1              RS=1;
  28   1              RW=0;
  29   1              LCDdata=RWdata;
  30   1              En=1;
  31   1              En=0;
  32   1      }
  33          
  34          unsigned char lcd_read_data(void){
  35   1              unsigned char Rdata;
  36   1              waiting();
  37   1              RS=1;
  38   1              RW=1;
  39   1              En=1;
  40   1              Rdata=P0;
  41   1              En=0;
  42   1              return Rdata;
  43   1      }
  44          
  45          void lcd_init(void){
  46   1              PSB=1;
  47   1              RET=1;
  48   1              lcd_write_command(BasicCommand);
  49   1              lcd_write_command(ClearScreen);
  50   1              lcd_write_command(AddrBackO);
  51   1              lcd_write_command(CurserOff);
  52   1              lcd_write_command(ClearScreen);
  53   1              lcd_write_command(CurserLeft);
  54   1      }
  55          
C51 COMPILER V8.02   GLCD                                                                  10/17/2013 17:03:06 PAGE 2   

  56          void display_string(unsigned char line,unsigned char *string){
  57   1      //Use the default command to display string. It can display chinese
  58   1      //line is the number of line. There are total 4 lines
  59   1      //string must be like this: unsigned char code string_1[]={"Test"}
  60   1      //Maxmum number of characters is 16.
  61   1          unsigned char  addr,i;
  62   1              unsigned char  maxnum=strlen(string);
  63   1          if(line==1)
  64   1            addr=0x80;
  65   1          else if(line==2)
  66   1            addr=0x90;
  67   1          else if(line==3)
  68   1            addr=0x88;
  69   1          else if(line==4)
  70   1                      addr=0x98;
  71   1          lcd_write_command(addr);
  72   1          for(i=0;i<maxnum;i++)
  73   1          {
  74   2                      lcd_write_data(*string++);
  75   2              } 
  76   1      }
  77          
  78          void first_page(void){
  79   1              unsigned char i,j;
  80   1              lcd_write_command(ExteCommandOff);
  81   1              for(i=0;i<16;i++){
  82   2                      for(j=0;j<32;j++){
  83   3                              lcd_write_command(0x80|j);
  84   3                              lcd_write_command(i|0x80);
  85   3                              lcd_write_data(0x00);
  86   3                              lcd_write_data(0x00);   
  87   3                      }
  88   2              }
  89   1              lcd_write_command(ExteCommandOn);
  90   1              lcd_write_command(BasicCommand);
  91   1      }
  92          
  93          void set_dot(unsigned char x,unsigned char y){
  94   1              if(x>=0 && x<=127 && y>=0 && y<=63){
  95   2              //initial variables
  96   2              unsigned int k=0x8000;
  97   2              unsigned char highdata,lowdata;
  98   2              //Open external command and graphic display
  99   2              lcd_write_command(ExteCommandOn);
 100   2              //According to y, adjust x and y
 101   2              if(y>=32){
 102   3                      y=y-32;
 103   3                      x=x+128;
 104   3              }
 105   2              //according to x, get which bit will be setted.
 106   2              k=k>>x%16;
 107   2              //write x and y to prepare to read data
 108   2              lcd_write_command(0x80|y);
 109   2              lcd_write_command((x/16)|0x80);
 110   2              //read exist data and change them to new data.
 111   2              highdata=lcd_read_data();
 112   2              highdata=lcd_read_data()|k>>8;
 113   2              lowdata=lcd_read_data()|k;
 114   2              //write x and y to prepare to write data
 115   2              lcd_write_command(0x80|y);
 116   2              lcd_write_command((x/16)|0x80);
 117   2              //write data
C51 COMPILER V8.02   GLCD                                                                  10/17/2013 17:03:06 PAGE 3   

 118   2              lcd_write_data(highdata);
 119   2              lcd_write_data(lowdata);
 120   2              //go back to basic command
 121   2              lcd_write_command(BasicCommand);
 122   2              }
 123   1      }
 124          
 125          void draw_line(unsigned char x1,unsigned char y1,unsigned char x2,unsigned char y2){    
 126   1              char dx,dy;//Difference between x1 and x2 and difference between y1 and y2
 127   1              unsigned char x,y,temp;//x,y: location of pixel.  temp: temp value for exchange of x and y
 128   1              int e;//adjust whether should be increased
 129   1              bit k,j;//k: upper slope flag.  j: negative slope flag
 130   1              dx=x2-x1;
 131   1              dy=y2-y1;
 132   1              //if the line is not from high to low, change it.
 133   1              if((dx<=0 && dy<=0) || (dx>=0 && dy<=0)){
 134   2                      temp=x2;
 135   2                      x2=x1;
 136   2                      x1=temp;
 137   2                      temp=y2;
 138   2                      y2=y1;
 139   2                      y1=temp;
 140   2                      dx=x2-x1;
 141   2                      dy=y2-y1;
 142   2              }
 143   1              //if negative slope, change to positive and get flag
 144   1              if(dx<0){
 145   2                      temp=x2;
 146   2                      x2=x1;
 147   2                      x1=temp;
 148   2                      dx=x2-x1;
 149   2                      j=1;
 150   2              }else{
 151   2                      j=0;
 152   2              }
 153   1              //if upper slope, get flag
 154   1              if(dx>=dy){
 155   2                      k=1;    
 156   2              }else{
 157   2                      k=0;
 158   2              }
 159   1              //Different slope, different default e
 160   1              if(k){
 161   2                      e=-dx;
 162   2              }else{
 163   2                      e=-dy;
 164   2              }
 165   1              //first point
 166   1              x=x1;
 167   1              y=y1;
 168   1              //if has been finished final point, finish drawing.
 169   1              while(x<=x2 && y<=y2){
 170   2                      //if the original slope is negative slope, should  change points back
 171   2                      if(j){
 172   3                              set_dot(x1+x2-x,y);
 173   3                      }else{
 174   3                              set_dot(x,y);
 175   3                      }
 176   2                      //different slope, different change of e
 177   2                      if(k){
 178   3                              e=e+2*dy;
 179   3                      }else{
C51 COMPILER V8.02   GLCD                                                                  10/17/2013 17:03:06 PAGE 4   

 180   3                              e=e+2*dx;
 181   3                      }
 182   2                      //according to e, adjust whether should go upper
 183   2                      if(e<=0){
 184   3                              //different slope, different way to go upper
 185   3                              if(k){
 186   4                                      x++;
 187   4                              }else{
 188   4                                      y++;
 189   4                              }
 190   3                      }else{
 191   3                              x++;
 192   3                              y++;
 193   3                              //different slope, different change of e
 194   3                              if(k){
 195   4                                      e=e-2*dx;
 196   4                              }else{
 197   4                                      e=e-2*dy;
 198   4                              }
 199   3                      }
 200   2              }
 201   1      }
 202          
 203          void draw_box(unsigned char x,unsigned char y,unsigned char num_x,unsigned char num_y,bit fill){
 204   1              //x: right upper coner x
 205   1              //y: right upper coner y
 206   1              //num_x: number of pixels in x
 207   1              //num_y: number os pixels in y
 208   1              //fill: fill or not
 209   1              if(fill){
 210   2                      unsigned char i;
 211   2                      for(i=y;i<y+num_y;i++){
 212   3                              draw_line(x,i,x+num_x-1,i);
 213   3                      }
 214   2              }else{
 215   2                      draw_line(x,y,x,y+num_y-1);
 216   2                      draw_line(x,y,x+num_x-1,y);
 217   2                      draw_line(x+num_x-1,y+num_y-1,x+num_x-1,y);
 218   2                      draw_line(x+num_x-1,y+num_y-1,x,y+num_y-1);
 219   2              }
 220   1      }
 221          
 222          void draw_frame(void){
 223   1              draw_box(0,0,128,64,0);
 224   1      }
 225          
 226          void draw_circle(unsigned char x,unsigned char y,unsigned char r,bit fill){
 227   1              //x: x of center
 228   1              //y: y of center
 229   1              //r: radius (number of pixels in radius)
 230   1              //fill: fill or not
 231   1              unsigned char a,b;
 232   1              char d;
 233   1              unsigned char i;
 234   1              //initial first point
 235   1              a=0;
 236   1              b=r-1;
 237   1              //initial distance
 238   1              d=1-r;
 239   1              while(a<=b){//Adjust if circle has been finished
 240   2                      //draw circle using a point of 1/8 circle to draw 8 points in all circle
 241   2                      if(fill){
C51 COMPILER V8.02   GLCD                                                                  10/17/2013 17:03:06 PAGE 5   

 242   3                              for(i=a+x;i>=x-a;i--){
 243   4                                      set_dot(i,b+y);
 244   4                                      set_dot(i,y-b);
 245   4                              }
 246   3                              for(i=b+x;i>=x-b;i--){
 247   4                                      set_dot(i,a+y);
 248   4                                      set_dot(i,y-a);
 249   4                              }
 250   3                      }else{
 251   3                              set_dot(a+x,b+y);
 252   3                              set_dot(a+x,y-b);
 253   3                              set_dot(x-a,b+y);
 254   3                              set_dot(x-a,y-b);
 255   3                              set_dot(b+x,a+y);
 256   3                              set_dot(b+x,y-a);
 257   3                              set_dot(x-b,a+y);
 258   3                              set_dot(x-b,y-a);       
 259   3                      }
 260   2                      //use distance to adjust next point.
 261   2                      if(d<0){
 262   3                              d+=2*a+3;
 263   3                      }else{
 264   3                              d+=2*(a-b)+5;
 265   3                              b--;
 266   3                      }
 267   2                      a++;
 268   2              }
 269   1      }
 270          
 271          void draw_8bits(unsigned char x,unsigned char y,unsigned char data8bit){
 272   1              unsigned char i=8;
 273   1              bit dot;
 274   1              while(i>0){
 275   2                      i--;
 276   2                      dot=0x01&(data8bit>>i);
 277   2                      if(dot){
 278   3                              set_dot(x,y);
 279   3                      }
 280   2                      x++;
 281   2              }
 282   1      }
 283          
 284          void draw_8bits90(unsigned char x,unsigned char y,unsigned char data8bit){
 285   1              unsigned char i=8;
 286   1              bit dot;
 287   1              while(i>0){
 288   2                      i--;
 289   2                      dot=0x01&(data8bit>>i);
 290   2                      if(dot){
 291   3                              set_dot(x,y);
 292   3                      }
 293   2                      y++;
 294   2              }
 295   1      }
 296          
 297          void draw_8bits180(unsigned char x,unsigned char y,unsigned char data8bit){
 298   1              unsigned char i=8;
 299   1              bit dot;
 300   1              while(i>0){
 301   2                      i--;
 302   2                      dot=0x01&(data8bit>>i);
 303   2                      if(dot){
C51 COMPILER V8.02   GLCD                                                                  10/17/2013 17:03:06 PAGE 6   

 304   3                              set_dot(x,y);
 305   3                      }
 306   2                      x--;
 307   2              }
 308   1      }
 309          
 310          void draw_8bits270(unsigned char x,unsigned char y,unsigned char data8bit){
 311   1              unsigned char i=8;
 312   1              bit dot;
 313   1              while(i>0){
 314   2                      i--;
 315   2                      dot=0x01&(data8bit>>i);
 316   2                      if(dot){
 317   3                              set_dot(x,y);
 318   3                      }
 319   2                      y--;
 320   2              }
 321   1      }
 322          
 323          void draw_picture(unsigned char x,unsigned char y,unsigned char x_l,unsigned char y_l,unsigned char *pictu
             -re){
 324   1              //x_l and y_l must be multiples of 8. They are the picture's length(in x of original system) and width(in
             - y of original system).
 325   1              unsigned char i=0;
 326   1              unsigned char j=0;
 327   1              int num=0;
 328   1              x_l=x_l/8;
 329   1              while(j<y_l){
 330   2                      j++;
 331   2                      while(i<x_l){
 332   3                              i++;
 333   3                              draw_8bits(x,y,picture[num]);
 334   3                              num++;
 335   3                              x+=8;
 336   3      
 337   3                      }
 338   2                      x-=8*i;
 339   2                      i=0;
 340   2                      y++;
 341   2              }
 342   1      }
 343          
 344          void draw_picture90(unsigned char x,unsigned char y,unsigned char x_l,unsigned char y_l,unsigned char *pic
             -ture){
 345   1              //x_l and y_l must be multiples of 8. They are the picture's length(in x of original system) and width(in
             - y of original system).
 346   1              unsigned char i=0;
 347   1              unsigned char j=0;
 348   1              int num=0;
 349   1              x_l=x_l/8;
 350   1              while(j<y_l){
 351   2                      j++;
 352   2                      while(i<x_l){
 353   3                              i++;
 354   3                              draw_8bits90(x,y,picture[num]);
 355   3                              num++;
 356   3                              y+=8;
 357   3      
 358   3                      }
 359   2                      y-=8*i;
 360   2                      i=0;
 361   2                      x--;
C51 COMPILER V8.02   GLCD                                                                  10/17/2013 17:03:06 PAGE 7   

 362   2              }
 363   1      }
 364          
 365          void draw_picture180(unsigned char x,unsigned char y,unsigned char x_l,unsigned char y_l,unsigned char *pi
             -cture){
 366   1              //x_l and y_l must be multiples of 8. They are the picture's length(in x of original system) and width(in
             - y of original system).
 367   1              unsigned char i=0;
 368   1              unsigned char j=0;
 369   1              int num=0;
 370   1              x_l=x_l/8;
 371   1              while(j<y_l){
 372   2                      j++;
 373   2                      while(i<x_l){
 374   3                              i++;
 375   3                              draw_8bits180(x,y,picture[num]);
 376   3                              num++;
 377   3                              x-=8;
 378   3      
 379   3                      }
 380   2                      x+=8*i;
 381   2                      i=0;
 382   2                      y--;
 383   2              }
 384   1      }
 385          
 386          void draw_picture270(unsigned char x,unsigned char y,unsigned char x_l,unsigned char y_l,unsigned char *pi
             -cture){
 387   1              //x_l and y_l must be multiples of 8. They are the picture's length(in x of original system) and width(in
             - y of original system).
 388   1              unsigned char i=0;
 389   1              unsigned char j=0;
 390   1              int num=0;
 391   1              x_l=x_l/8;
 392   1              while(j<y_l){
 393   2                      j++;
 394   2                      while(i<x_l){
 395   3                              i++;
 396   3                              draw_8bits270(x,y,picture[num]);
 397   3                              num++;
 398   3                              y-=8;
 399   3      
 400   3                      }
 401   2                      y+=8*i;
 402   2                      i=0;
 403   2                      x++;
 404   2              }
 405   1      }
 406          
 407          void display_string_58(unsigned char x,unsigned char y,unsigned char *string, unsigned int degree){
 408   1              //degree: 0, 90, 180, 270
 409   1              unsigned char code ASCII58[] =              // ASCII
 410   1              {
 411   1              0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // - -
 412   1      
 413   1              0x20,0x20,0x20,0x20,0x20,0x00,0x20,0x00, // -!-
 414   1      
 415   1              0x50,0x50,0x50,0x00,0x00,0x00,0x00,0x00, // -"-
 416   1      
 417   1              0x50,0x50,0xF8,0x50,0xF8,0x50,0x50,0x00, // -#-
 418   1      
 419   1              0x20,0x78,0xC0,0x70,0x28,0xF0,0x20,0x00, // -$-
C51 COMPILER V8.02   GLCD                                                                  10/17/2013 17:03:06 PAGE 8   

 420   1      
 421   1              0xC0,0xC8,0x10,0x20,0x40,0x98,0x18,0x00, // -%-
 422   1      
 423   1              0x40,0xA0,0xA0,0x40,0xA8,0x90,0x68,0x00, // -&-
 424   1      
 425   1              0x30,0x20,0x40,0x00,0x00,0x00,0x00,0x00, // -'-
 426   1      
 427   1              0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00, // -(-
 428   1      
 429   1              0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00, // -)-
 430   1      
 431   1              0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00, // -*-
 432   1      
 433   1              0x20,0x20,0x20,0xF8,0x20,0x20,0x20,0x00, // -+-
 434   1      
 435   1              0x00,0x00,0x00,0x00,0x60,0x40,0x80,0x00, // -,-
 436   1      
 437   1              0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00, // ---
 438   1      
 439   1              0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x00, // -.-
 440   1      
 441   1              0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00, // -/-
 442   1      
 443   1              0x70,0x88,0x98,0xA8,0xC8,0x88,0x70,0x00, // -0-
 444   1      
 445   1              0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00, // -1-
 446   1      
 447   1              0x70,0x88,0x08,0x30,0x40,0x80,0xF8,0x00, // -2-
 448   1      
 449   1              0xF8,0x08,0x10,0x30,0x08,0x88,0x70,0x00, // -3-
 450   1      
 451   1              0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00, // -4-
 452   1      
 453   1              0xF8,0x80,0xF0,0x08,0x08,0x88,0x70,0x00, // -5-
 454   1      
 455   1              0x38,0x40,0x80,0xF0,0x88,0x88,0x70,0x00, // -6-
 456   1      
 457   1              0xF8,0x08,0x10,0x20,0x40,0x40,0x40,0x00, // -7-
 458   1      
 459   1              0x70,0x88,0x88,0x70,0x88,0x88,0x70,0x00, // -8-
 460   1      
 461   1              0x70,0x88,0x88,0x78,0x08,0x10,0xE0,0x00, // -9-
 462   1      
 463   1              0x00,0x60,0x60,0x00,0x60,0x60,0x00,0x00, // -:-
 464   1      
 465   1              0x00,0x60,0x60,0x00,0x60,0x60,0x80,0x00, // -;-
 466   1      
 467   1              0x10,0x20,0x40,0x80,0x40,0x20,0x10,0x00, // -<-
 468   1      
 469   1              0x00,0x00,0xF8,0x00,0xF8,0x00,0x00,0x00, // -=-
 470   1      
 471   1              0x40,0x20,0x10,0x08,0x10,0x20,0x40,0x00, // ->-
 472   1      
 473   1              0x70,0x88,0x10,0x20,0x20,0x00,0x20,0x00, // -?-
 474   1      
 475   1              0x70,0x88,0xB8,0xA8,0xB8,0x80,0x78,0x00, // -@-
 476   1      
 477   1              0x20,0x50,0x88,0x88,0xF8,0x88,0x88,0x00, // -A-
 478   1      
 479   1              0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00, // -B-
 480   1      
 481   1              0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00, // -C-
C51 COMPILER V8.02   GLCD                                                                  10/17/2013 17:03:06 PAGE 9   

 482   1      
 483   1              0xF0,0x88,0x88,0x88,0x88,0x88,0xF0,0x00, // -D-
 484   1      
 485   1              0xF8,0x80,0x80,0xF0,0x80,0x80,0xF8,0x00, // -E-
 486   1      
 487   1              0xF8,0x80,0x80,0xF0,0x80,0x80,0x80,0x00, // -F-
 488   1      
 489   1              0x70,0x88,0x80,0x80,0xB8,0x88,0x78,0x00, // -G-
 490   1      
 491   1              0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00, // -H-
 492   1      
 493   1              0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00, // -I-
 494   1      
 495   1              0x38,0x10,0x10,0x10,0x10,0x90,0x60,0x00, // -J-
 496   1      
 497   1              0x88,0x90,0xA0,0xC0,0xA0,0x90,0x88,0x00, // -K-
 498   1      
 499   1              0x80,0x80,0x80,0x80,0x80,0x80,0xF8,0x00, // -L-
 500   1      
 501   1              0x88,0xD8,0xA8,0xA8,0x88,0x88,0x88,0x00, // -M-
 502   1      
 503   1              0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00, // -N-
 504   1      
 505   1              0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00, // -O-
 506   1      
 507   1              0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00, // -P-
 508   1      
 509   1              0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00, // -Q-
 510   1      
 511   1              0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00, // -R-
 512   1      
 513   1              0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00, // -S-
 514   1      
 515   1              0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00, // -T-
 516   1      
 517   1              0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00, // -U-
 518   1      
 519   1              0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00, // -V-
 520   1      
 521   1              0x88,0x88,0x88,0xA8,0xA8,0xD8,0x88,0x00, // -W-
 522   1      
 523   1              0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00, // -X-
 524   1      
 525   1              0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00, // -Y-
 526   1      
 527   1              0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00, // -Z-
 528   1      
 529   1              0xF0,0xC0,0xC0,0xC0,0xC0,0xC0,0xF0,0x00, // -[-
 530   1      
 531   1              0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00, // -\-
 532   1      
 533   1              0x78,0x18,0x18,0x18,0x18,0x18,0x78,0x00, // -]-
 534   1      
 535   1              0x20,0x70,0xA8,0x20,0x20,0x20,0x20,0x00, // -^-
 536   1      
 537   1              0x00,0x20,0x40,0xF8,0x40,0x20,0x00,0x00, // -_-
 538   1      
 539   1              0x20,0x10,0x08,0x00,0x00,0x00,0x00,0x00, // -`-
 540   1      
 541   1              0x00,0x00,0xE0,0x10,0x70,0x90,0x68,0x00, // -a-
 542   1      
 543   1              0x80,0x80,0xB0,0xC8,0x88,0xC8,0xB0,0x00, // -b-
C51 COMPILER V8.02   GLCD                                                                  10/17/2013 17:03:06 PAGE 10  

 544   1      
 545   1              0x00,0x00,0x70,0x88,0x80,0x80,0x70,0x00, // -c-
 546   1      
 547   1              0x08,0x08,0x68,0x98,0x88,0x98,0x68,0x00, // -d-
 548   1      
 549   1              0x00,0x00,0x70,0x88,0xF0,0x80,0x70,0x00, // -e-
 550   1      
 551   1              0x30,0x48,0x40,0xF0,0x40,0x40,0x40,0x00, // -f-
 552   1      
 553   1              0x00,0x00,0x70,0x88,0x88,0x78,0x08,0xF0, // -g-
 554   1      
 555   1              0x80,0x80,0xB0,0xC8,0x88,0x88,0x88,0x00, // -h-
 556   1      
 557   1              0x20,0x00,0x00,0x20,0x20,0x20,0x20,0x00, // -i-
 558   1      
 559   1              0x10,0x00,0x00,0x30,0x10,0x10,0x10,0x60, // -j-
 560   1      
 561   1              0x80,0x80,0x90,0xA0,0xC0,0xA0,0x98,0x00, // -k-
 562   1      
 563   1              0x60,0x20,0x20,0x20,0x20,0x20,0x70,0x00, // -l-
 564   1      
 565   1              0x00,0x00,0x50,0xA8,0xA8,0xA8,0xA8,0x00, // -m-
 566   1      
 567   1              0x00,0x00,0xB0,0x48,0x48,0x48,0x48,0x00, // -n-
 568   1      
 569   1              0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00, // -o-
 570   1      
 571   1              0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80, // -p-
 572   1      
 573   1              0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08, // -q-
 574   1      
 575   1              0x00,0x00,0xB0,0x48,0x40,0x40,0x40,0x00, // -r-
 576   1      
 577   1              0x00,0x00,0x78,0x80,0x70,0x08,0xF0,0x00, // -s-
 578   1      
 579   1              0x40,0x40,0xF8,0x40,0x40,0x48,0x30,0x00, // -t-
 580   1      
 581   1              0x00,0x00,0x90,0x90,0x90,0x90,0x68,0x00, // -u-
 582   1      
 583   1              0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00, // -v-
 584   1      
 585   1              0x00,0x00,0xA8,0xA8,0xA8,0xA8,0x50,0x00, // -w-
 586   1      
 587   1              0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00, // -x-
 588   1      
 589   1              0x00,0x00,0x88,0x88,0x98,0x68,0x08,0xF0, // -y-
 590   1      
 591   1              0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00, // -z-
 592   1      
 593   1              0x20,0x40,0x40,0x80,0x40,0x40,0x20,0x00, // -{-
 594   1      
 595   1              0x20,0x20,0x20,0x00,0x20,0x20,0x20,0x00, // -|-
 596   1      
 597   1              0x20,0x10,0x10,0x08,0x10,0x10,0x20,0x00, // -}-
 598   1      
 599   1              0x00,0x00,0x40,0xA8,0x10,0x00,0x00,0x00
 600   1              };
 601   1              unsigned int i;
 602   1              unsigned int maxnum=strlen(string);
 603   1              unsigned int num;
 604   1              unsigned char m,n;
 605   1              unsigned char x_l=1;
C51 COMPILER V8.02   GLCD                                                                  10/17/2013 17:03:06 PAGE 11  

 606   1              unsigned char y_l=8;
 607   1              unsigned char b=y;
 608   1              unsigned char a=x;
 609   1              if(degree==0){
 610   2                      for(i=0;i<maxnum;i++){
 611   3                              x=a+6*i;
 612   3                              y=b;
 613   3                              num=(string[i]-32)*8;
 614   3                              //
 615   3                              m=0;
 616   3                              n=0;
 617   3                              while(n<y_l){
 618   4                                      n++;
 619   4                                      while(m<x_l){
 620   5                                              m++;
 621   5                                              draw_8bits(x,y,ASCII58[num]);
 622   5                                              num++;
 623   5                                              x+=8;
 624   5      
 625   5                                      }
 626   4                                      x-=8*m;
 627   4                                      m=0;
 628   4                                      y++;
 629   4                              }
 630   3                      }
 631   2              }
 632   1              else if(degree==90){
 633   2                      for(i=0;i<maxnum;i++){
 634   3                              x=a;
 635   3                              y=b+6*i;
 636   3                              num=(string[i]-32)*8;
 637   3                              //
 638   3                              m=0;
 639   3                              n=0;
 640   3                              while(n<y_l){
 641   4                                      n++;
 642   4                                      while(m<x_l){
 643   5                                              m++;
 644   5                                              draw_8bits90(x,y,ASCII58[num]);
 645   5                                              num++;
 646   5                                              y+=8;
 647   5      
 648   5                                      }
 649   4                                      y-=8*m;
 650   4                                      m=0;
 651   4                                      x--;
 652   4                              }
 653   3                      }
 654   2              }else if(degree==180){
 655   2                      for(i=0;i<maxnum;i++){
 656   3                              x=a-6*i;
 657   3                              y=b;
 658   3                              num=(string[i]-32)*8;
 659   3                              //
 660   3                              m=0;
 661   3                              n=0;
 662   3                              while(n<y_l){
 663   4                                      n++;
 664   4                                      while(m<x_l){
 665   5                                              m++;
 666   5                                              draw_8bits180(x,y,ASCII58[num]);
 667   5                                              num++;
C51 COMPILER V8.02   GLCD                                                                  10/17/2013 17:03:06 PAGE 12  

 668   5                                              x-=8;
 669   5      
 670   5                                      }
 671   4                                      x+=8*m;
 672   4                                      m=0;
 673   4                                      y--;
 674   4                              }
 675   3                      }
 676   2              }else if(degree==270){
 677   2                      for(i=0;i<maxnum;i++){
 678   3                              x=a;
 679   3                              y=b-6*i;
 680   3                              num=(string[i]-32)*8;
 681   3                              //
 682   3                              m=0;
 683   3                              n=0;
 684   3                              while(n<y_l){
 685   4                                      n++;
 686   4                                      while(m<x_l){
 687   5                                              m++;
 688   5                                              draw_8bits270(x,y,ASCII58[num]);
 689   5                                              num++;
 690   5                                              y-=8;
 691   5      
 692   5                                      }
 693   4                                      y+=8*m;
 694   4                                      m=0;
 695   4                                      x++;
 696   4                              }
 697   3                      }
 698   2              }
 699   1      }
 700          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2304    ----
   CONSTANT SIZE    =    760    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      96
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       8
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
